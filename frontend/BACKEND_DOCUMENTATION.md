# Техническая Документация Бэкенда "ProDvor"

Этот документ служит центральным источником информации для разработки, развертывания и поддержки серверной части платформы "ProDvor".

## 1. Обзор архитектуры

Мы используем микросервисную архитектуру для обеспечения гибкости, масштабируемости и независимого развертывания компонентов.

- **API Gateway (Kong)**: Единая точка входа для всех клиентских запросов. Отвечает за маршрутизацию, аутентификацию (проверка JWT), ограничение скорости и логирование.
- **Identity Provider (Keycloak)**: Централизованное управление пользователями, ролями, аутентификацией и авторизацией. Для надежности в продакшене использует **выделенную PostgreSQL базу данных**.
- **Основные сервисы (Node.js)**: Набор микросервисов, отвечающих за конкретную бизнес-логику (`user-service`, `team-service`, `tournament-service` и т.д.).
- **Брокер сообщений (Kafka & RabbitMQ)**: Асинхронное взаимодействие между сервисами. Используется для доставки сообщений в `chat-service`, обработки оффлайн-сообщений, уведомлений и фоновых задач.
- **База данных (PostgreSQL)**: Основное хранилище данных для всех сервисов.
- **Кэш (Redis)**: Распределенный кэш для часто запрашиваемых данных, сессий и поддержки очередей.
- **Хранилище файлов (S3-совместимое)**: Object Storage для хранения пользовательского контента (аватары, медиа).
- **Шлюз реального времени (WebSockets)**: `WebsocketsModule` на базе Socket.IO для двунаправленной связи с клиентами (чаты, онлайн-статусы, уведомления).
- **AI Gateway (Genkit)**: Отдельный шлюз или сервис, который инкапсулирует взаимодействие с моделями Google AI.

## 2. Технологический стек

| Компонент            | Технология                      | Примечание                                                       |
| :------------------- | :------------------------------ | :--------------------------------------------------------------- |
| **Среда выполнения** | Node.js (v20+)                  | Используем LTS-версию для стабильности.                          |
| **Фреймворк**        | NestJS                          | Предоставляет модульную архитектуру и DI "из коробки".           |
| **База данных**      | PostgreSQL (v15+)               | Надежная и масштабируемая реляционная СУБД.                      |
| **ORM**              | Prisma                          | Упрощает взаимодействие с базой данных и миграции.               |
| **API Gateway**      | Kong                            | Централизованная обработка входящих запросов.                    |
| **IdP**              | Keycloak                        | Управление пользователями, ролями и аутентификацией.             |
| **Брокер сообщений** | Apache Kafka & RabbitMQ         | Для асинхронных операций, стриминга и сверхвысоких нагрузок.     |
| **Кеширование**      | Redis & `@nestjs/cache-manager` | Для кэширования ответов API, сессий, часто запрашиваемых данных. |
| **Хранилище файлов** | S3-совместимое (MinIO, GCS)     | AWS SDK v3 для взаимодействия.                                   |
| **Контейнеризация**  | Docker, Docker Compose          | Для локальной разработки и развертывания.                        |
| **Мониторинг**       | Prometheus, Grafana, Loki       | Сбор и визуализация метрик и логов.                              |
| **AI-интеграция**    | Genkit                          | Инструментарий для работы с генеративным AI.                     |

## 3. Ключевые архитектурные решения

### 3.1. Распределение асинхронных задач: Kafka vs. RabbitMQ

Для асинхронного взаимодействия мы используем два брокера сообщений, применяя принцип "правильный инструмент для правильной задачи". Это позволяет нам строить более надежную и специализированную систему.

| Сценарий                         | Брокер       | Реализация и Обоснование                                                                                                                                                                                                         |
| :------------------------------- | :----------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Чаты (Real-time)**             | **Kafka**    | **Уже реализовано.** Для обмена сообщениями в реальном времени, где важен порядок и высокая пропускная способность, мы используем Kafka. `ChatConsumer` слушает топик `chat-messages`.                                           |
| **Уведомления**                  | **RabbitMQ** | **Уже реализовано.** Для асинхронной и гарантированной доставки уведомлений (новые друзья, результаты матчей) используется RabbitMQ. `NotificationsConsumer` обрабатывает эти события.                                           |
| **Фоновые задачи (Task Queues)** | **RabbitMQ** | **Принятый паттерн.** Для "тяжелых" задач, таких как обработка загруженных видео, генерация PDF-отчетов или массовые email-рассылки. Это позволяет не блокировать основной поток приложения и масштабировать воркеры независимо. |
| **Игровая телеметрия**           | **Kafka**    | **Планируется.** Для сбора потока событий во время матча (убийства, перемещения). Это позволит в будущем строить аналитику в реальном времени и детальные повторы.                                                               |
| **Видео-трансляции**             | **Kafka**    | **Будущая фича.** Kafka отлично подходит для обработки потоков видео-данных, что является ключевым требованием для этой фичи.                                                                                                    |

### 3.2. RabbitMQ как очередь задач (Task Queue)

Вместо добавления в стек еще одной технологии (например, BullMQ), мы используем все возможности RabbitMQ. Библиотека `@golevelup/nestjs-rabbitmq` предоставляет удобные декораторы (`@RabbitSubscribe`), которые автоматизируют создание очередей, обработку сообщений и подтверждения (ACK/NACK), что гарантирует надежную доставку задач. Это позволяет нам эффективно решать задачи обработки медиа, массовых рассылок, генерации отчетов и сложных вычислений.

### 3.3. Стратегия кэширования

Мы используем **распределенный кэш на базе Redis**, управляемый через `@nestjs/cache-manager`. Этот подход выбран для обеспечения **масштабируемости**. Когда приложение работает в нескольких экземплярах (контейнерах), общий кэш Redis гарантирует, что закэшированные данные доступны всем экземплярам, что значительно снижает нагрузку на базу данных. In-memory кэш в таком сценарии был бы неэффективен. Для генерации консистентных ключей используется `cache.utils.ts`.

### 3.4. Хранение и доставка статичных файлов (Object Storage + CDN)

Хранение файлов на диске сервера является анти-паттерном. Мы используем двухкомпонентный подход:

1.  **Хранилище (Object Storage):** Любой S3-совместимый сервис (MinIO для локальной разработки, Google Cloud Storage/Amazon S3 для продакшена). Бэкенд через `StorageModule` получает от клиента запрос на загрузку, генерирует **presigned URL** и отдает его клиенту. Клиент загружает файл напрямую в S3, минуя наш сервер. В базу данных сохраняется только ключ файла.
2.  **Доставка (CDN):** Cloudflare, Google Cloud CDN и т.д. Кэширует файлы для сверхбыстрой доставки пользователям по всему миру.

### 3.5. Система наблюдаемости (Observability)

Мы придерживаемся "трех столпов наблюдаемости":

1.  **Логирование:** Приложение генерирует структурированные JSON-логи с помощью `JsonLogger`. `HttpLoggingInterceptor` автоматически логирует все HTTP-запросы.
2.  **Метрики:** `MetricsModule` на базе `prom-client` предоставляет эндпоинт `/metrics` для сбора метрик системой Prometheus.
3.  **Обработка ошибок:** Глобальный `HttpExceptionFilter` перехватывает все ошибки, логирует их в JSON-формате и готовит для отправки в системы вроде Sentry.

## 4. Аутентификация и авторизация

Процесс подробно описан в `AUTH_IMPLEMENTATION.md`. Ключевые моменты:

1.  **Защита API**: Все эндпоинты, кроме публичных, защищены в Kong с помощью `openid-connect` плагина.
2.  **Информация о пользователе**: Kong, после валидации JWT, передает информацию о пользователе (claims) в заголовках (`X-Userinfo`, `X-Authenticated-Userid`). Сервисы доверяют этим заголовкам.
3.  **Регистрация**: Эндпоинт `/register` публичен и использует **Keycloak Admin API** для создания нового пользователя.

## 5. Взаимодействие с AI-сервисами (Genkit)

Для обеспечения безопасности и контроля, Genkit-флоу не вызываются напрямую с фронтенда.

1.  **Backend-for-Frontend (BFF)**: Эндпоинты в `AiController` выступают в роли прокси для Genkit.
2.  **Аутентификация**: Эти прокси-эндпоинты защищены JWT.
3.  **Безопасность ключей**: `GOOGLE_API_KEY` хранится только на бэкенде.
