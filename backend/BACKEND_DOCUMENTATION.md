# Техническая Документация Бэкенда "ProDvor"

Этот документ служит центральным источником информации для разработки, развертывания и поддержки серверной части платформы "ProDvor".

## 1. Обзор архитектуры

Мы используем микросервисную архитектуру для обеспечения гибкости, масштабируемости и независимого развертывания компонентов.

-   **API Gateway (Kong)**: Единая точка входа для всех клиентских запросов. Отвечает за маршрутизацию, аутентификацию (проверка JWT), ограничение скорости и логирование.
-   **Identity Provider (Keycloak)**: Централизованное управление пользователями, ролями, аутентификацией и авторизацией. Для надежности в продакшене использует **выделенную PostgreSQL базу данных**.
-   **Основные сервисы (Node.js)**: Набор микросервисов, отвечающих за конкретную бизнес-логику (`user-service`, `team-service`, `tournament-service` и т.д.).
-   **Брокер сообщений (Kafka & RabbitMQ)**: Асинхронное взаимодействие между сервисами. Используется для доставки сообщений в `chat-service`, обработки оффлайн-сообщений, уведомлений и фоновых задач.
-   **База данных (PostgreSQL)**: Основное хранилище данных для всех сервисов.
-   **Кэш (Redis)**: Распределенный кэш для часто запрашиваемых данных, сессий и поддержки очередей.
-   **Хранилище файлов (S3-совместимое)**: Object Storage для хранения пользовательского контента (аватары, медиа).
-   **Шлюз реального времени (WebSockets)**: `WebsocketsModule` на базе Socket.IO для двунаправленной связи с клиентами (чаты, онлайн-статусы, уведомления).
-   **AI Gateway (Genkit)**: Отдельный шлюз или сервис, который инкапсулирует взаимодействие с моделями Google AI.

## 2. Технологический стек

| Компонент            | Технология                    | Примечание                                                          |
| :---                 | :---                          | :---                                                                |
| **Среда выполнения** | Node.js (v20+)                | Используем LTS-версию для стабильности.                             |
| **Фреймворк**        | NestJS                        | Предоставляет модульную архитектуру и DI "из коробки".              |
| **База данных**      | PostgreSQL (v15+)             | Надежная и масштабируемая реляционная СУБД.                         |
| **ORM**              | Prisma                        | Упрощает взаимодействие с базой данных и миграции.                  |
| **API Gateway**      | Kong                          | Централизованная обработка входящих запросов.                       |
| **IdP**              | Keycloak                      | Управление пользователями, ролями и аутентификацией.                |
| **Брокер сообщений** | Apache Kafka & RabbitMQ       | Для асинхронных операций, стриминга и сверхвысоких нагрузок.         |
| **Кеширование**      | Redis & `@nestjs/cache-manager` | Для кэширования ответов API, сессий, часто запрашиваемых данных.    |
| **Хранилище файлов** | S3-совместимое (MinIO, GCS)   | AWS SDK v3 для взаимодействия.                                      |
| **Контейнеризация**  | Docker, Docker Compose        | Для локальной разработки и развертывания.                           |
| **Мониторинг**       | Prometheus, Grafana, Loki     | Сбор и визуализация метрик и логов.                                 |
| **AI-интеграция**    | Genkit                        | Инструментарий для работы с генеративным AI.                        |


## 3. Ключевые архитектурные решения

### 3.1. Модель "Правильный инструмент для правильной задачи": Kafka + RabbitMQ

| Задача                                     | Рекомендуемый брокер | Почему?                                                                                                       |
| :----------------------------------------- | :------------------- | :------------------------------------------------------------------------------------------------------------ |
| **Сообщения в чате в реальном времени**                       | **Kafka**            | Нужна высокая пропускная способность, гарантированный порядок и возможность хранить историю для новых участников. |
| **Уведомления, фоновые задачи**            | **RabbitMQ**         | Идеально для **очередей задач (task queues)**. Можно легко маршрутизировать задания разным "воркерам" (email-sender, push-sender, report-generator). |
| **Статистика матчей в реальном времени**   | **Kafka**            | Это классический поток событий (event stream), который можно будет анализировать в реальном времени.         |
| **Видео-трансляции (будущая фича)**        | **Kafka**            | Это основная причина выбора Kafka. Он создан для обработки потоков данных такого масштаба.                    |

Такой подход "polyglot messaging" позволяет нам строить более надежную и специализированную систему, готовую к любым нагрузкам.

### 3.2. RabbitMQ как очередь задач (Task Queue)

Вместо добавления в стек еще одной технологии (например, BullMQ), мы используем все возможности RabbitMQ. Библиотека `@golevelup/nestjs-rabbitmq` предоставляет удобные декораторы (`@RabbitSubscribe`), которые автоматизируют создание очередей, обработку сообщений и подтверждения (ACK/NACK), что гарантирует надежную доставку задач. Это позволяет нам эффективно решать задачи обработки медиа, массовых рассылок, генерации отчетов и сложных вычислений.

### 3.3. Стратегия кэширования

Мы используем **распределенный кэш на базе Redis**, управляемый через `@nestjs/cache-manager`. Этот подход выбран для обеспечения **масштабируемости**. Когда приложение работает в нескольких экземплярах (контейнерах), общий кэш Redis гарантирует, что закэшированные данные доступны всем экземплярам, что значительно снижает нагрузку на базу данных. In-memory кэш в таком сценарии был бы неэффективен. Для генерации консистентных ключей используется `cache.utils.ts`.

### 3.4. Хранение и доставка статичных файлов (Object Storage + CDN)

Хранение файлов на диске сервера является анти-паттерном. Мы используем двухкомпонентный подход:
1.  **Хранилище (Object Storage):** Любой S3-совместимый сервис (MinIO для локальной разработки, Google Cloud Storage/Amazon S3 для продакшена). Бэкенд через `StorageModule` получает от клиента запрос на загрузку, генерирует **presigned URL** и отдает его клиенту. Клиент загружает файл напрямую в S3, минуя наш сервер. В базу данных сохраняется только ключ файла.
2.  **Доставка (CDN):** Cloudflare, Google Cloud CDN и т.д. Кэширует файлы для сверхбыстрой доставки пользователям по всему миру.

### 3.5. Система наблюдаемости (Observability)

Мы придерживаемся "трех столпов наблюдаемости":
1.  **Логирование:** Приложение генерирует структурированные JSON-логи с помощью `JsonLogger`. `HttpLoggingInterceptor` автоматически логирует все HTTP-запросы.
2.  **Метрики:** `MetricsModule` на базе `prom-client` предоставляет эндпоинт `/metrics` для сбора метрик системой Prometheus.
3.  **Обработка ошибок:** Глобальный `HttpExceptionFilter` перехватывает все ошибки, логирует их в JSON-формате и готовит для отправки в системы вроде Sentry.

## 4. Аутентификация и авторизация

Процесс подробно описан в `AUTH_IMPLEMENTATION.md`. Ключевые моменты:
1.  **Защита API**: Все эндпоинты, кроме публичных, защищены в Kong с помощью `openid-connect` плагина.
2.  **Информация о пользователе**: Kong, после валидации JWT, передает информацию о пользователе (claims) в заголовках (`X-Userinfo`, `X-Authenticated-Userid`). Сервисы доверяют этим заголовкам.
3.  **Регистрация**: Эндпоинт `/register` публичен и использует **Keycloak Admin API** для создания нового пользователя.

## 5. Взаимодействие с AI-сервисами (Genkit)

Для обеспечения безопасности и контроля, Genkit-флоу не вызываются напрямую с фронтенда.
1.  **Backend-for-Frontend (BFF)**: Эндпоинты в `AiController` выступают в роли прокси для Genkit.
2.  **Аутентификация**: Эти прокси-эндпоинты защищены JWT.
3.  **Безопасность ключей**: `GOOGLE_API_KEY` хранится только на бэкенде.
