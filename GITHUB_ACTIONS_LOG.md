# Лог Рабочих Решений для GitHub Actions

Этот документ служит для фиксации проверенных и работающих решений, примененных к CI/CD пайплайну (`.github/workflows/main.yml`) и связанным с ним файлам (`Dockerfile`, `docker-compose.ci.yml`).

## 1. Multi-stage сборка в Dockerfile для pnpm-воркспейсов (Окончательное решение)

**Проблема:** Постоянные ошибки `prisma: not found`, `nest: not found` и ошибки типов TypeScript (`Module '"@prisma/client"' has no exported member '...'`) во время сборки в CI. Это происходило из-за неверного порядка копирования файлов и установки зависимостей, в результате чего Prisma Client не генерировался до начала компиляции.

**Рабочее решение:** Использование многоэтапной сборки (multi-stage build) с **критически важной и строгой последовательностью** команд для `pnpm`.

- **Стадия `builder`:**
    1. Устанавливаем `WORKDIR /usr/src/app`.
    2. Копируются **только** корневые файлы манифеста (`package.json`, `pnpm-lock.yaml`, `pnpm-workspace.yaml`, `.npmrc`) и `tsconfig.json`.
    3. **Важно:** Копируются файлы `package.json` **каждого** воркспейса в их соответствующие директории (например, `COPY backend/package.json ./backend/`). Это необходимо, чтобы `pnpm` понял, что нужно устанавливать зависимости для этих воркспейсов.
    4. Копируется `prisma/schema.prisma` бэкенда в соответствующую директорию (`COPY backend/prisma ./backend/prisma`).
    5. Запускается `pnpm install --frozen-lockfile`. Этот шаг установит **все** зависимости (включая `devDependencies`) для **всех** воркспейсов, так как он "видит" их `package.json`. На этом же этапе автоматически сработает `postinstall` скрипт для `prisma generate`.
    6. **После `pnpm install`** копируется **весь остальной исходный код** (`COPY . .`).
    7. Запускается `pnpm --filter prodvor-backend build` для компиляции TypeScript-кода, который теперь видит сгенерированный на предыдущем шаге Prisma Client.

- **Стадия `runner` (финальный образ):**
    1. Используется легковесный базовый образ (например, `node:20-alpine`).
    2. Устанавливаем `WORKDIR /app`.
    3. Из стадии `builder` копируются **только** необходимые для запуска артефакты:
        -   Скомпилированный проект (`/usr/src/app/backend/dist`).
        -   `node_modules` бэкенда (`/usr/src/app/backend/node_modules`).
        -   `package.json` бэкенда.

**Обоснование:** Этот подход гарантирует, что на момент компиляции все инструменты (`nest`, `prisma`) и все сгенерированные типы доступны, а финальный образ остается маленьким и содержит только то, что нужно для запуска приложения. `pnpm` работает в ожидаемом им контексте монорепозитория.

## 2. Оркестрация сервисов в CI

**Проблема:** Нестабильный запуск, ошибки `service "migrations" didn't complete successfully`, ошибки подключения к базе данных.

**Рабочее решение:**

- **Явное использование всех compose-файлов:** Все вызовы `docker compose` в `.github/workflows/main.yml` должны явно включать все необходимые файлы: `docker compose -f docker-compose.yml -f docker-compose.ci.yml <command>`.
- **Явная сборка образов перед запуском:** В `.github/workflows/main.yml` перед `docker compose up` необходимо принудительно собрать свежие образы с помощью `docker/build-push-action@v5` с опцией `load: true`.
- **Правильная последовательность запуска:**
    1.  Сервис `db` имеет `healthcheck`.
    2.  Сервис `migrations` в `docker-compose.ci.yml` зависит от `db` (`depends_on: { db: { condition: service_healthy } }`).
    3.  Сервис `backend` зависит от `migrations` (`depends_on: { migrations: { condition: service_completed_successfully } }`).

**Обоснование:** Это обеспечивает строгий порядок: база данных должна быть полностью готова, затем успешно применяются миграции, и только после этого стартует бэкенд.

## 3. Управление версией pnpm

**Проблема:** Локальная среда или CI могут использовать глобально установленную версию `pnpm`, которая отличается от указанной в `package.json` (`packageManager`), что приводит к ошибкам.

**Рабочее решение:**

- **Использование Corepack:** Corepack - это инструмент, поставляемый с Node.js для управления версиями пакетных менеджеров.
- **Активация:**
  - **Локально:** Выполните `corepack enable` один раз, чтобы `pnpm` автоматически использовал версию из `package.json`.
  - **В CI:** Добавьте шаг `run: corepack enable` в `.github/workflows/main.yml` перед установкой зависимостей.

**Обоснование:** Это гарантирует, что и локально, и в CI будет использоваться одна и та же, строго определенная версия `pnpm`, что устраняет целый класс проблем с разрешением зависимостей.

## 4. Установка OpenSSL для Prisma

**Проблема:** Ошибка `Prisma failed to detect the libssl/openssl version to use` во время `pnpm install` в CI. Базовый образ `node:20-alpine` не содержит необходимой библиотеки OpenSSL, от которой зависит Prisma для работы с базой данных.

**Рабочее решение:**

- **Явная установка `openssl`:** В `backend/Dockerfile` на базовой стадии (`base`) необходимо добавить команду для установки пакета.
  ```dockerfile
  FROM node:20-alpine as base
  # Устанавливаем OpenSSL, необходимый для Prisma
  RUN apk add --no-cache openssl
  # ... остальные команды
  ```
- **Порядок:** Этот шаг должен выполняться **до** `pnpm install`, чтобы к моменту запуска `prisma generate` библиотека уже была доступна в системе.

**Обоснование:** Это решает проблему на уровне системных зависимостей контейнера, обеспечивая Prisma необходимым окружением для корректной работы.
